/*
 * vkmmc_core.comp — Monte Carlo photon transport via Vulkan ray query
 * Direct port of mmc_optix_core.cu (Single-AS RT-MMC)
 *
 * For NVIDIA GPUs: uncomment the next line for native atomicAdd(float)
 * For AMD/Intel:   keep it commented out (uses CAS fallback)
 *
 * Compile: glslangValidator --target-env vulkan1.2 -e main -o vkmmc_core.spv vkmmc_core.comp
 */
#version 460
#extension GL_EXT_ray_query : require

// Uncomment for NVIDIA (Turing+) — ~10x faster atomic accumulation
//#define USE_ATOMIC_FLOAT

#ifdef USE_ATOMIC_FLOAT
    #extension GL_EXT_shader_atomic_float : require
#endif

layout(local_size_x = 64) in;  // workgroup size

// ==================== Descriptor Bindings ====================

layout(set = 0, binding = 0) uniform accelerationStructureEXT scene;

layout(std430, set = 0, binding = 1) readonly buffer FaceBuffer {
    vec4 face_normal[];  // .xyz = normal, .w = packed front/back media
};

struct Medium {
    float mua, mus, g, n;
};

layout(std430, set = 0, binding = 2) readonly buffer MediaBuffer {
    Medium media[];
};

#ifdef USE_ATOMIC_FLOAT
layout(std430, set = 0, binding = 3) buffer OutputBuffer {
    float output_data[];
};
#else
layout(std430, set = 0, binding = 3) buffer OutputBuffer {
    uint output_data[];
};
#endif

layout(std140, set = 0, binding = 4) uniform SimParams {
    int   src_type;
    int   _pad0, _pad1, _pad2;
    vec4  src_pos;
    vec4  src_dir;
    vec4  src_param1;
    vec4  src_param2;
    vec4  grid_min;       // grid origin (nmin)
    vec4  grid_extent;    // grid size (nmax - nmin)
    uvec4 grid_stride;    // .x=nx, .y=nx*ny, .z=nx*ny*nz, .w=total_voxels
    float voxel_scale;    // 1.0 / voxel_size
    float time_start, time_end, inv_timestep;
    int   max_gate;
    uint  initial_medium;
    uint  do_reflect;
    int   output_type;
    int   photons_per_thread;
    int   extra_photons;
    uint  total_threads;
    uint  num_media;
    uint  rng_seed;
    uint  _pad3;
};

layout(std430, set = 0, binding = 5) readonly buffer SeedBuffer {
    uvec4 thread_seeds[];
};

// ==================== Constants ====================

const float INV_SPEED_OF_LIGHT = 3.335640951981520e-12;  // 1/c0 in s/mm
const float SAFETY_DIST        = 0.001;     // forward nudge after boundary hit
const float DOUBLE_SAFETY_DIST = 0.002;     // retraction on reflection
const float TWO_PI             = 6.28318530717959;
const float FLOAT_EPSILON      = 1.19209290E-07;
const float FLOAT_MAX          = 3.402823466e+38;
const float RAY_MIN_DIST       = 1e-5;      // min ray t to prevent self-intersection

const uint MEDIUM_UNKNOWN = 0xFFFFFFFFu;
const uint MEDIUM_DEAD    = 0xFFFFFFFEu;
const uint MEDIUM_AMBIENT = 0u;

const int OUTPUT_FLUX     = 0;
const int OUTPUT_FLUENCE  = 1;
const int OUTPUT_ENERGY   = 2;

// ==================== xorshift128+ RNG ====================

float rand_uniform01(inout uvec4 state) {
    uvec2 s1 = state.xy, s0 = state.zw;
    state.xy = s0;
    s1 ^= uvec2(s1.x << 23u, (s1.y << 23u) | (s1.x >> 9u));
    uvec2 new_s1 = s1 ^ s0
                   ^ uvec2((s1.x >> 18u) | (s1.y << 14u), s1.y >> 18u)
                   ^ uvec2((s0.x >>  5u) | (s0.y << 27u), s0.y >>  5u);
    state.zw = new_s1;
    uint result_lo = new_s1.x + s0.x;
    return uintBitsToFloat(0x3F800000u | (result_lo >> 9u)) - 1.0;
}

float rand_range(inout uvec4 state, float lo, float hi) {
    return (hi - lo) * rand_uniform01(state) + lo;
}

float rand_scatlen(inout uvec4 state) {
    return -log(rand_uniform01(state) + FLOAT_EPSILON);
}

// ==================== Ray Tracing ====================

bool trace_ray(vec3 origin, vec3 direction, float min_dist, float max_dist,
               out float hit_dist, out int triangle_id, out bool is_front_face) {
    rayQueryEXT query;
    rayQueryInitializeEXT(query, scene, gl_RayFlagsNoneEXT, 0xFF,
                          origin, min_dist, direction, max_dist);

    while (rayQueryProceedEXT(query)) {}

    if (rayQueryGetIntersectionTypeEXT(query, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
        hit_dist    = rayQueryGetIntersectionTEXT(query, true);
        triangle_id = rayQueryGetIntersectionPrimitiveIndexEXT(query, true);
        is_front_face = rayQueryGetIntersectionFrontFaceEXT(query, true);
        return true;
    }

    return false;
}

void unpack_media(float packed, out uint front_medium, out uint back_medium) {
    uint bits = floatBitsToUint(packed);
    front_medium = bits >> 16u;
    back_medium  = bits & 0xFFFFu;
}

// ==================== Output Accumulation ====================

void atomic_add_float(uint index, float value) {
#ifdef USE_ATOMIC_FLOAT
    atomicAdd(output_data[index], value);
#else
    uint prev = output_data[index], next_val, old_val;

    do {
        old_val  = prev;
        next_val = floatBitsToUint(uintBitsToFloat(old_val) + value);
        prev     = atomicCompSwap(output_data[index], old_val, next_val);
    } while (prev != old_val);

#endif
}

uint voxel_index(vec3 rel_pos) {
    uint ix = rel_pos.x > 0.0 ? uint(min(rel_pos.x, grid_extent.x) * voxel_scale) : 0u;
    uint iy = rel_pos.y > 0.0 ? uint(min(rel_pos.y, grid_extent.y) * voxel_scale) : 0u;
    uint iz = rel_pos.z > 0.0 ? uint(min(rel_pos.z, grid_extent.z) * voxel_scale) : 0u;
    return iz * grid_stride.y + iy * grid_stride.x + ix;
}

uint time_gate_offset(float time_of_flight) {
    return uint(min(int((time_of_flight - time_start) * inv_timestep), max_gate - 1)) * grid_stride.z;
}

// Accumulate energy along a photon path segment (matching accumulateOutput)
void accumulate_along_path(vec3 pos, vec3 dir, uint medium_id,
                           float weight, float time_of_flight, float path_length) {
    Medium prop = media[medium_id];
    int segment_count = (int(path_length * voxel_scale) + 1) << 1;
    float segment_len = path_length / float(segment_count);
    float segment_decay = exp(-prop.mua * segment_len);

    float energy_loss;

    if (output_type == OUTPUT_ENERGY) {
        energy_loss = weight * (1.0 - segment_decay);
    } else {
        energy_loss = (prop.mua > 0.0) ? weight * (1.0 - segment_decay) / prop.mua : 0.0;
    }

    vec3 step_vec   = segment_len * dir;
    vec3 segment_mid = pos - grid_min.xyz + 0.5 * step_vec;
    float current_time = time_of_flight + segment_len * INV_SPEED_OF_LIGHT * prop.n;

    uint  prev_voxel = time_gate_offset(current_time) + voxel_index(segment_mid);
    float accum_weight = energy_loss;

    for (int i = 1; i < segment_count; ++i) {
        energy_loss *= segment_decay;
        segment_mid += step_vec;
        current_time += segment_len * INV_SPEED_OF_LIGHT * prop.n;
        uint curr_voxel = time_gate_offset(current_time) + voxel_index(segment_mid);

        if (curr_voxel != prev_voxel) {
            atomic_add_float(prev_voxel, accum_weight);
            prev_voxel = curr_voxel;
            accum_weight = 0.0;
        }

        accum_weight += energy_loss;
    }

    atomic_add_float(prev_voxel, accum_weight);
}

// ==================== Scattering ====================

vec3 rotate_direction(vec3 dir, vec2 zenith, vec2 azimuth) {
    if (dir.z > -1.0 + FLOAT_EPSILON && dir.z < 1.0 - FLOAT_EPSILON) {
        float sin2 = 1.0 - dir.z * dir.z;
        float scale = zenith.x * inversesqrt(sin2);
        return scale * (azimuth.y * vec3(dir.x * dir.z, dir.y * dir.z, -sin2)
                        + azimuth.x * vec3(-dir.y, dir.x, 0.0))
               + zenith.y * dir;
    } else {
        return vec3(zenith.x * azimuth.y, zenith.x * azimuth.x,
                    dir.z > 0.0 ? zenith.y : -zenith.y);
    }
}

vec2 henyey_greenstein(float anisotropy, inout uvec4 rng) {
    float cos_theta;

    if (abs(anisotropy) > FLOAT_EPSILON) {
        float temp = (1.0 - anisotropy * anisotropy)
                     / (1.0 - anisotropy + 2.0 * anisotropy * rand_uniform01(rng));
        cos_theta = (1.0 + anisotropy * anisotropy - temp * temp)
                    / (2.0 * anisotropy);
        cos_theta = clamp(cos_theta, -1.0, 1.0);
    } else {
        cos_theta = 2.0 * rand_uniform01(rng) - 1.0;
    }

    return vec2(sin(acos(cos_theta)), cos_theta);
}

vec3 scatter_direction(vec3 dir, float anisotropy, inout uvec4 rng) {
    float phi = rand_range(rng, 0.0, TWO_PI);
    vec2 zenith = henyey_greenstein(anisotropy, rng);
    return rotate_direction(dir, zenith, vec2(sin(phi), cos(phi)));
}

// ==================== Fresnel Reflection ====================

bool handle_reflection(vec3 normal, float n_in, float n_out,
                       inout uvec4 rng, inout vec3 pos, inout vec3 dir) {
    float cos_incident = abs(dot(dir, normal));
    float n_in2 = n_in * n_in;
    float n_out2 = n_out * n_out;
    float cos2_transmitted = 1.0 - n_in2 / n_out2 * (1.0 - cos_incident * cos_incident);

    if (cos2_transmitted > 0.0) {
        // Partial reflection — compute Fresnel coefficient
        float cos_transmitted = sqrt(cos2_transmitted);
        float re = n_in2 * cos_incident * cos_incident + n_out2 * cos2_transmitted;
        float im = 2.0 * n_in * n_out * cos_incident * cos_transmitted;
        float r_parallel = (re - im) / (re + im);

        re = n_out2 * cos_incident * cos_incident + n_in2 * cos_transmitted * cos_transmitted;
        float r_total = (r_parallel + (re - im) / (re + im)) * 0.5;

        if (rand_uniform01(rng) <= r_total) {
            // Reflect
            pos -= dir * DOUBLE_SAFETY_DIST;
            dir += -2.0 * cos_incident * normal;
        } else {
            // Transmit (refract)
            dir += -cos_incident * normal;
            dir = cos_transmitted * normal + n_in / n_out * dir;
            dir *= inversesqrt(dot(dir, dir));
            return false;  // transmitted
        }
    } else {
        // Total internal reflection
        pos -= dir * DOUBLE_SAFETY_DIST;
        dir += -2.0 * cos_incident * normal;
    }

    dir *= inversesqrt(dot(dir, dir));
    return true;  // reflected
}

// ==================== Photon Launch ====================

void launch_photon(inout vec3 pos, inout vec3 dir, inout float weight,
                   inout float scat_len, inout float time_of_flight,
                   inout uint medium_id, inout uvec4 rng) {
    pos = src_pos.xyz;
    dir = src_dir.xyz;
    weight = 1.0;
    time_of_flight = 0.0;
    medium_id = initial_medium;

    // Planar source
    if (src_type == 4) {
        float rand_u = rand_uniform01(rng);
        float rand_v = rand_uniform01(rng);
        pos = src_pos.xyz + rand_u * src_param1.xyz + rand_v * src_param2.xyz;
    }

    scat_len = rand_scatlen(rng);

    // Determine initial medium by ray query if unknown
    if (medium_id == MEDIUM_UNKNOWN) {
        float hit_dist;
        int triangle_id;
        bool is_front;

        if (trace_ray(pos, dir, 0.0, FLOAT_MAX, hit_dist, triangle_id, is_front)) {
            uint front_med, back_med;
            unpack_media(face_normal[triangle_id].w, front_med, back_med);
            medium_id = is_front ? front_med : back_med;
        } else {
            medium_id = MEDIUM_DEAD;
        }
    }
}

// ==================== Main Kernel ====================

void main() {
    uint thread_id = gl_GlobalInvocationID.x;

    if (thread_id >= total_threads) {
        return;
    }

    uvec4 rng = thread_seeds[thread_id];
    int photons_done = 0;
    int max_photons = photons_per_thread + int(thread_id < uint(extra_photons));

    // Launch first photon
    vec3  pos, dir;
    float weight, scat_len, time_of_flight;
    uint  medium_id;
    launch_photon(pos, dir, weight, scat_len, time_of_flight, medium_id, rng);

    // Main simulation loop
    while (photons_done < max_photons) {

        // ---- Propagate if photon is alive ----
        if (medium_id != MEDIUM_DEAD) {
            Medium prop = media[medium_id];

            // Skip propagation for ambient/void medium (mus=0)
            if (prop.mus < FLOAT_EPSILON) {
                medium_id = MEDIUM_DEAD;
            } else {
                float max_travel = scat_len / prop.mus;

                float hit_dist;
                int   triangle_id;
                bool  is_front;
                bool  hit_boundary = trace_ray(pos, dir, RAY_MIN_DIST, max_travel,
                                               hit_dist, triangle_id, is_front);

                if (hit_boundary) {
                    // ======== Boundary intersection (closest-hit) ========
                    uint front_med, back_med;
                    unpack_media(face_normal[triangle_id].w, front_med, back_med);

                    Medium current_prop = media[medium_id];
                    float travel_dist = min(hit_dist,
                                            current_prop.mus > 0.0 ? scat_len / current_prop.mus : FLOAT_MAX);

                    // Deposit energy along path
                    accumulate_along_path(pos, dir, medium_id, weight,
                                          time_of_flight, travel_dist);

                    // Advance photon past boundary
                    pos += dir * (travel_dist + SAFETY_DIST);
                    weight *= exp(-current_prop.mua * travel_dist);
                    time_of_flight += travel_dist * INV_SPEED_OF_LIGHT * current_prop.n;
                    scat_len -= travel_dist * current_prop.mus;

                    // Cross boundary (assume index-matched)
                    medium_id = is_front ? back_med : front_med;

                    // Handle refractive index mismatch
                    if (do_reflect > 0u && current_prop.n != media[medium_id].n) {
                        vec3 normal = is_front
                                      ? -face_normal[triangle_id].xyz
                                      :  face_normal[triangle_id].xyz;

                        if (handle_reflection(normal, current_prop.n, media[medium_id].n,
                                              rng, pos, dir)) {
                            // Reflected — restore original medium
                            medium_id = is_front ? front_med : back_med;
                        }

                        // Terminate if reflected/refracted into ambient
                        if (medium_id == MEDIUM_AMBIENT) {
                            medium_id = MEDIUM_DEAD;
                        }
                    }

                } else {
                    // ======== No boundary hit — scattering event (miss) ========
                    Medium current_prop = media[medium_id];
                    float travel_dist = scat_len / current_prop.mus;

                    // Deposit energy along path
                    accumulate_along_path(pos, dir, medium_id, weight,
                                          time_of_flight, travel_dist);

                    // Advance photon
                    pos += dir * travel_dist;
                    weight *= exp(-current_prop.mua * travel_dist);
                    time_of_flight += travel_dist * INV_SPEED_OF_LIGHT * current_prop.n;

                    // Scatter into new direction
                    dir = scatter_direction(dir, current_prop.g, rng);
                    scat_len = rand_scatlen(rng);
                }
            } // end if (prop.mus >= FLOAT_EPSILON)
        }

        // ---- Check termination and relaunch ----
        if (!(medium_id != MEDIUM_DEAD && time_of_flight < time_end)) {
            launch_photon(pos, dir, weight, scat_len, time_of_flight, medium_id, rng);
            ++photons_done;
        }
    }
}