/*
 * vkmmc_core.comp — Monte Carlo photon transport via Vulkan ray query
 *
 * Supports two modes:
 *   1. Mesh mode (do_csg=0): front/back media labels per triangle (tetrahedral mesh)
 *   2. CSG mode  (do_csg=1): shape-based, each triangle stores only back-material (Tag).
 *      A per-photon 8-byte state buffer tracks enclosing surfaces.
 *      Highest media ID among all enclosing surfaces determines the current medium.
 *
 * Curvature-informed reflection: when has_curvature=1, uses per-node principal
 * curvature to estimate the true surface normal at the intersection point,
 *
 * Optimizations for curvature mode:
 *   - Main ray trace uses trace_ray (no barycentrics) always
 *   - Barycentrics only fetched via a second trace when curvature normal is needed
 *   - Curvature normal computed by accumulating per-vertex contributions sequentially
 *     to reduce register pressure (no 3x simultaneous vec4 loads)
 *   - Single get_reflection_normal() used everywhere (no inlined duplication)
 *
 * Compile: glslangValidator --target-env vulkan1.2 -e main -o vkmmc_core.spv vkmmc_core.comp
 */
#version 460
#extension GL_EXT_ray_query : require

//#define USE_ATOMIC_FLOAT

#ifdef USE_ATOMIC_FLOAT
    #extension GL_EXT_shader_atomic_float : require
#endif

layout(local_size_x = 64) in;

layout(set = 0, binding = 0) uniform accelerationStructureEXT scene;

layout(std430, set = 0, binding = 1) readonly buffer FaceBuffer {
    vec4 face_normal[];
};

struct Medium {
    float mua, mus, g, n;
};
layout(std430, set = 0, binding = 2) readonly buffer MediaBuffer { Medium media[]; };

#ifdef USE_ATOMIC_FLOAT
layout(std430, set = 0, binding = 3) buffer OutputBuffer { float output_data[]; };
#else
layout(std430, set = 0, binding = 3) buffer OutputBuffer { uint output_data[]; };
#endif

// MCParams / SimParams layout — must match C++ struct exactly
// std140 rules: vec4 aligned to 16 bytes, scalars packed in groups of 4
//
// offset  0: srcpos[4]         vec4
// offset 16: srcdir[4]         vec4
// offset 32: srcparam1[4]      vec4
// offset 48: srcparam2[4]      vec4
// offset 64: nmin[4]           vec4  (grid_min)
// offset 80: nmax[4]           vec4  (grid_extent)
// offset 96: crop0[4]          uvec4 (grid_stride)
//
// offset 112: dstep, tstart, tend, Rtstep          4 floats
// offset 128: srctype, maxgate, outputtype, isreflect   3 ints + 1 uint
// offset 144: mediumid0, total_threads, num_media, seed  4 uints
// offset 160: do_csg, has_curvature, threadphoton, oddphoton  2 uint + 2 int
// offset 176: minenergy, roulettesize, pad, pad    4 floats

layout(std140, set = 0, binding = 4) uniform SimParams {
    vec4  src_pos;           // offset 0
    vec4  src_dir;           // offset 16
    vec4  src_param1;        // offset 32
    vec4  src_param2;        // offset 48
    vec4  grid_min;          // offset 64
    vec4  grid_extent;       // offset 80
    uvec4 grid_stride;       // offset 96

    // offset 112: scalar row 0
    float voxel_scale;       // 112
    float time_start;        // 116
    float time_end;          // 120
    float inv_timestep;      // 124

    // offset 128: scalar row 1
    int   src_type;          // 128
    int   max_gate;          // 132
    int   output_type;       // 136
    uint  do_reflect;        // 140

    // offset 144: scalar row 2
    uint  initial_medium;    // 144
    uint  total_threads;     // 148
    uint  num_media;         // 152
    uint  rng_seed;          // 156

    // offset 160: scalar row 3
    uint  do_csg;            // 160
    uint  has_curvature;     // 164
    int   photons_per_thread;// 168
    int   extra_photons;     // 172

    // offset 176: scalar row 4 (NEW — Russian Roulette)
    float minenergy;         // 176
    float roulettesize;      // 180
    float _pad1;             // 184
    float _pad2;             // 188
};

layout(std430, set = 0, binding = 5) readonly buffer SeedBuffer { uvec4 thread_seeds[]; };

struct NodeCurv {
    vec4 vnorm_k1;   // .xyz = vertex normal, .w = k1
    vec4 pdir_k2;    // .xyz = principal direction 1, .w = k2
    vec4 node_pos;   // .xyz = node world position
};
layout(std430, set = 0, binding = 6) readonly buffer CurvBuffer { NodeCurv node_curv[]; };

// ==================== Constants ====================

const float INV_C0       = 3.335640951981520e-12;
const float SAFETY_DIST  = 0.001;
const float DOUBLE_SAFETY = 0.002;
const float TWO_PI       = 6.28318530717959;
const float FEPS         = 1.19209290E-07;
const float FMAX         = 3.402823466e+38;
const float RAY_TMIN     = 1e-5;

const uint MEDIUM_UNKNOWN = 0xFFFFFFFFu;
const uint MEDIUM_DEAD    = 0xFFFFFFFEu;
const uint MEDIUM_AMBIENT = 0u;
const uint MEDIUM_BBOX    = 0xFFFFu;   // bounding box termination label
const int  OUT_FLUX = 0, OUT_FLUENCE = 1, OUT_ENERGY = 2;
const uint FLAT_FLAG = 0x80000000u;

// ==================== RNG ====================

float rand01(inout uvec4 st) {
    uvec2 s1 = st.xy, s0 = st.zw;
    st.xy = s0;
    s1 ^= uvec2(s1.x << 23u, (s1.y << 23u) | (s1.x >> 9u));
    uvec2 ns = s1 ^ s0 ^ uvec2((s1.x >> 18u) | (s1.y << 14u), s1.y >> 18u)
               ^ uvec2((s0.x >> 5u) | (s0.y << 27u), s0.y >> 5u);
    st.zw = ns;
    return uintBitsToFloat(0x3F800000u | ((ns.x + s0.x) >> 9u)) - 1.0;
}

float rand_range(inout uvec4 s, float a, float b) {
    return (b - a) * rand01(s) + a;
}

float rand_scatlen(inout uvec4 s) {
    return -log(rand01(s) + FEPS);
}

// ==================== Ray Tracing ====================

bool trace_ray(vec3 o, vec3 d, float tmin, float tmax,
               out float dist, out int tri_id, out bool front_face) {
    rayQueryEXT q;
    rayQueryInitializeEXT(q, scene, gl_RayFlagsNoneEXT, 0xFF, o, tmin, d, tmax);

    while (rayQueryProceedEXT(q)) {}

    if (rayQueryGetIntersectionTypeEXT(q, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
        dist = rayQueryGetIntersectionTEXT(q, true);
        tri_id = rayQueryGetIntersectionPrimitiveIndexEXT(q, true);
        front_face = rayQueryGetIntersectionFrontFaceEXT(q, true);
        return true;
    }

    return false;
}

void unpack_media(float pw, out uint front_med, out uint back_med) {
    uint p = floatBitsToUint(pw) & 0x7FFFFFFFu;
    front_med = p >> 16u;
    back_med  = p & 0xFFFFu;
}

bool is_flat_triangle(float pw) {
    return (floatBitsToUint(pw) & FLAT_FLAG) != 0u;
}

// ==================== Media State Buffer ====================

uint ms_get(uvec2 ms, int slot) {
    uint word = (slot < 4) ? ms.x : ms.y;
    return (word >> (uint(slot & 3) * 8u)) & 0xFFu;
}

uvec2 ms_set(uvec2 ms, int slot, uint val) {
    uint shift = uint(slot & 3) * 8u;
    uint mask = 0xFFu << shift;

    if (slot < 4) {
        ms.x = (ms.x & ~mask) | ((val & 0xFFu) << shift);
    } else {
        ms.y = (ms.y & ~mask) | ((val & 0xFFu) << shift);
    }

    return ms;
}

uvec2 ms_enter(uvec2 ms, uint back_id) {
    if (back_id == 0u) {
        return ms;
    }

    uint cur = ms_get(ms, 0);
    uint mx = max(cur, back_id), dem = (mx == back_id) ? cur : back_id;
    ms = ms_set(ms, 0, mx);

    if (dem > 0u)
        for (int i = 1; i < 8; i++)
            if (ms_get(ms, i) == 0u) {
                ms = ms_set(ms, i, dem);
                break;
            }

    return ms;
}

uvec2 ms_leave(uvec2 ms, uint back_id) {
    if (back_id == 0u) {
        return ms;
    }

    for (int i = 0; i < 8; i++)
        if (ms_get(ms, i) == back_id) {
            ms = ms_set(ms, i, 0u);
            break;
        }

    uint mx = 0u;
    int ms2 = -1;

    for (int i = 0; i < 8; i++) {
        uint v = ms_get(ms, i);

        if (v > mx) {
            mx = v;
            ms2 = i;
        }
    }

    if (ms2 > 0) {
        ms = ms_set(ms, ms2, 0u);
        ms = ms_set(ms, 0, mx);
    } else if (ms2 < 0) {
        ms = ms_set(ms, 0, 0u);
    }

    return ms;
}

// ==================== Output ====================

void atomic_add_float(uint idx, float val) {
#ifdef USE_ATOMIC_FLOAT
    atomicAdd(output_data[idx], val);
#else
    uint prev = output_data[idx], nv, old;

    do {
        old = prev;
        nv = floatBitsToUint(uintBitsToFloat(old) + val);
        prev = atomicCompSwap(output_data[idx], old, nv);
    } while (prev != old);

#endif
}

uint voxel_index(vec3 rp) {
    uint ix = rp.x > 0.0 ? uint(min(rp.x, grid_extent.x) * voxel_scale) : 0u;
    uint iy = rp.y > 0.0 ? uint(min(rp.y, grid_extent.y) * voxel_scale) : 0u;
    uint iz = rp.z > 0.0 ? uint(min(rp.z, grid_extent.z) * voxel_scale) : 0u;
    return iz * grid_stride.y + iy * grid_stride.x + ix;
}

uint time_offset(float tof) {
    return uint(min(int((tof - time_start) * inv_timestep), max_gate - 1)) * grid_stride.z;
}

void accumulate(vec3 p, vec3 d, uint mid, float w, float tof, float L) {
    Medium pr = media[mid];
    int sc = (int(L * voxel_scale) + 1) << 1;
    float sl = L / float(sc), decay = exp(-pr.mua * sl);
    float loss = (output_type == OUT_ENERGY) ? w * (1.0 - decay)
                 : (pr.mua > 0.0 ? w * (1.0 - decay) / pr.mua : 0.0);
    vec3 step = sl * d, sm = p - grid_min.xyz + 0.5 * step;
    float ct = tof + sl * INV_C0 * pr.n;
    uint oe = time_offset(ct) + voxel_index(sm);
    float ow = loss;

    for (int i = 1; i < sc; ++i) {
        loss *= decay;
        sm += step;
        ct += sl * INV_C0 * pr.n;
        uint ne = time_offset(ct) + voxel_index(sm);

        if (ne != oe) {
            atomic_add_float(oe, ow);
            oe = ne;
            ow = 0.0;
        }

        ow += loss;
    }

    atomic_add_float(oe, ow);
}

// ==================== Scattering ====================

vec3 rotate_dir(vec3 v, vec2 z, vec2 a) {
    if (v.z > -1.0 + FEPS && v.z < 1.0 - FEPS) {
        float s2 = 1.0 - v.z * v.z, sc = z.x * inversesqrt(s2);
        return sc * (a.y * vec3(v.x * v.z, v.y * v.z, -s2) + a.x * vec3(-v.y, v.x, 0.0)) + z.y * v;
    }

    return vec3(z.x * a.y, z.x * a.x, v.z > 0.0 ? z.y : -z.y);
}

vec3 scatter_dir(vec3 d, float g, inout uvec4 rng) {
    float ct;

    if (abs(g) > FEPS) {
        float t = (1.0 - g * g) / (1.0 - g + 2.0 * g * rand01(rng));
        ct = clamp((1.0 + g * g - t * t) / (2.0 * g), -1.0, 1.0);
    } else {
        ct = 2.0 * rand01(rng) - 1.0;
    }

    float phi = rand_range(rng, 0.0, TWO_PI);
    return rotate_dir(d, vec2(sin(acos(ct)), ct), vec2(sin(phi), cos(phi)));
}

// ==================== Fresnel ====================

bool do_reflection(vec3 N, float n1, float n2, inout uvec4 rng, inout vec3 p, inout vec3 d) {
    float ci = -dot(d, N);

    if (ci < 0.0) {
        N = -N;
        ci = -ci;
    }

    float n12 = n1 * n1, n22 = n2 * n2;
    float ct2 = 1.0 - n12 / n22 * (1.0 - ci * ci);

    if (ct2 > 0.0) {
        float ct = sqrt(ct2);
        float re = n12 * ci * ci + n22 * ct2, im = 2.0 * n1 * n2 * ci * ct;
        float rp = (re - im) / (re + im);
        re = n22 * ci * ci + n12 * ct * ct;
        float rt = (rp + (re - im) / (re + im)) * 0.5;

        if (rand01(rng) <= rt) {
            p -= d * DOUBLE_SAFETY;
            d = d + 2.0 * ci * N;
        } else {
            float ratio = n1 / n2;
            d = ratio * d + (ratio * ci - ct) * N;
            d *= inversesqrt(dot(d, d));
            return false;
        }
    } else {
        p -= d * DOUBLE_SAFETY;
        d = d + 2.0 * ci * N;
    }

    d *= inversesqrt(dot(d, d));
    return true;
}

// ==================== Curvature Normal ====================
// Accumulates per-vertex curvature contributions sequentially
// to minimize register pressure. Only reads 2 vec4s per vertex
// (vnorm_k1 and pdir_k2), plus node_pos.

vec3 get_curvature_normal_at(int tri_id, vec3 hit_pos) {
    if (has_curvature == 0u || is_flat_triangle(face_normal[tri_id * 2].w)) {
        return face_normal[tri_id * 2].xyz;
    }

    vec4 vidx_raw = face_normal[tri_id * 2 + 1];
    vec3 NB = vec3(0.0);

    for (int vi = 0; vi < 3; vi++) {
        uint idx = floatBitsToUint(vidx_raw[vi]);
        vec4 nk = node_curv[idx].vnorm_k1;
        vec4 pk = node_curv[idx].pdir_k2;
        vec3 di = hit_pos - node_curv[idx].node_pos.xyz;
        vec3 vi2 = cross(pk.xyz, nk.xyz);

        // CORRECTED: Add curvature correction for convex surfaces
        NB += nk.xyz + nk.w * dot(di, pk.xyz) * pk.xyz
              + pk.w * dot(di, vi2) * vi2;
    }

    NB = normalize(NB);

    if (dot(NB, face_normal[tri_id * 2].xyz) < 0.0) {
        NB = -NB;
    }

    return NB;
}

// ==================== Reflection Normal ====================
// Returns normal oriented toward photon's incoming side.
// Only computes curvature when actually needed (refractive boundary).

vec3 get_reflection_normal(int tri_id, bool front_face, vec3 hit_pos) {
    vec3 N_out;

    if (has_curvature > 0u) {
        N_out = get_curvature_normal_at(tri_id, hit_pos);
    } else {
        N_out = face_normal[tri_id * 2].xyz;
    }

    return front_face ? N_out : -N_out;
}

// ==================== Photon Launch ====================

void launch_photon(inout vec3 p, inout vec3 d, inout float w, inout float slen,
                   inout float tof, inout uint mid, inout uvec2 mstate, inout uvec4 rng) {
    p = src_pos.xyz;
    d = src_dir.xyz;
    w = 1.0;
    tof = 0.0;
    mstate = uvec2(0u, 0u);

    if (src_type == 4) {
        p = src_pos.xyz + rand01(rng) * src_param1.xyz + rand01(rng) * src_param2.xyz;
    } else if (src_type == 8) {
        float r0 = sqrt(rand01(rng)) * src_param1.x, phi = TWO_PI * rand01(rng);
        float cp = cos(phi), sp = sin(phi);
        vec3 sd = src_dir.xyz;

        if (sd.z > -1.0 + FEPS && sd.z < 1.0 - FEPS) {
            float t0 = 1.0 - sd.z * sd.z, t1 = r0 * inversesqrt(t0);
            p.x += t1 * (sd.x * sd.z * cp - sd.y * sp);
            p.y += t1 * (sd.y * sd.z * cp + sd.x * sp);
            p.z -= t1 * t0 * cp;
        } else {
            p.x += r0 * cp;
            p.y += r0 * sp;
        }
    }

    slen = rand_scatlen(rng);

    if (do_csg > 0u) {
        mstate = uvec2(0u, 0u);
        uint parity = 0u;
        vec3 wp = p;

        for (int wk = 0; wk < 64; wk++) {
            float hd;
            int tid;
            bool ff;

            if (!trace_ray(wp, d, RAY_TMIN, FMAX, hd, tid, ff)) {
                break;
            }

            uint fm, bm;
            unpack_media(face_normal[tid * 2].w, fm, bm);

            if (bm > 0u && bm <= 8u) {
                parity ^= (1u << (bm - 1u));
            }

            wp += d * (hd + SAFETY_DIST);
        }

        for (int i = 0; i < 8; i++)
            if ((parity & (1u << i)) != 0u) {
                mstate = ms_enter(mstate, uint(i + 1));
            }

        mid = ms_get(mstate, 0);

        if (mid == 0u) {
            float hd;
            int tid;
            bool ff;

            if (trace_ray(p, d, 0.0, FMAX, hd, tid, ff) && ff) {
                uint fm, bm;
                unpack_media(face_normal[tid * 2].w, fm, bm);
                p += d * (hd + SAFETY_DIST);
                mstate = ms_enter(mstate, bm);
                mid = ms_get(mstate, 0);

                if (do_reflect > 0u && mid < num_media) {
                    float n_out = media[mid].n;

                    if (1.0 != n_out) {
                        vec3 hp = p - d * SAFETY_DIST;
                        vec3 N = get_reflection_normal(tid, true, hp);

                        if (do_reflection(N, 1.0, n_out, rng, p, d)) {
                            mstate = uvec2(0u, 0u);
                            mid = MEDIUM_DEAD;
                            w = 0.0;
                        }
                    }
                }
            } else {
                mid = MEDIUM_DEAD;
            }
        }
    } else {
        mid = initial_medium;

        if (mid == MEDIUM_UNKNOWN) {
            float hd;
            int tid;
            bool ff;

            if (trace_ray(p, d, 0.0, FMAX, hd, tid, ff)) {
                uint fm, bm;
                unpack_media(face_normal[tid * 2].w, fm, bm);
                mid = ff ? fm : bm;
            } else {
                mid = MEDIUM_DEAD;
            }
        }
    }
}

// ==================== Main ====================

void main() {
    uint tid = gl_GlobalInvocationID.x;

    if (tid >= total_threads) {
        return;
    }

    if (tid == 0u) {
        atomicExchange(output_data[grid_stride.w - 11u], has_curvature);
    }

    uvec4 rng = thread_seeds[tid];
    int done = 0, maxph = photons_per_thread + int(tid < uint(extra_photons));

    vec3 pos, dir;
    float weight, slen, tof;
    uint mid;
    uvec2 mstate;

    launch_photon(pos, dir, weight, slen, tof, mid, mstate, rng);

    while (done < maxph) {

        if (mid != MEDIUM_DEAD && mid != MEDIUM_AMBIENT) {
            Medium prop = media[mid];

            bool is_transparent = (prop.mus < FEPS);
            float max_dist = is_transparent ? FMAX : slen / prop.mus;
            float hd;
            int tri;
            bool ff;

            // OPTIMIZATION: always use trace_ray (no barycentrics)
            // Curvature normal is computed from hit_pos, not barycentrics
            bool hit = trace_ray(pos, dir, RAY_TMIN, max_dist, hd, tri, ff);

            if (!hit && is_transparent) {
                mid = MEDIUM_DEAD;
            } else if (hit) {
                uint fm, bm;
                unpack_media(face_normal[tri * 2].w, fm, bm);
                float L = is_transparent ? hd : min(hd, slen / prop.mus);

                accumulate(pos, dir, mid, weight, tof, L);
                pos += dir * (L + SAFETY_DIST);
                weight *= exp(-prop.mua * L);
                tof += L * INV_C0 * prop.n;

                if (!is_transparent) {
                    slen -= L * prop.mus;
                }

                if (do_csg > 0u) {
                    uint old_mid = mid;
                    uvec2 new_ms = ff ? ms_enter(mstate, bm) : ms_leave(mstate, bm);
                    uint new_mid = ms_get(new_ms, 0);

                    bool reflected = false;

                    if (do_reflect > 0u && new_mid != old_mid
                            && new_mid < num_media && old_mid < num_media) {
                        float n_in = media[old_mid].n;
                        float n_out = (new_mid == 0u) ? 1.0 : media[new_mid].n;

                        if (n_in != n_out) {
                            // Only compute curvature normal at actual refractive boundary
                            vec3 hp = pos - dir * SAFETY_DIST;
                            vec3 N = get_reflection_normal(tri, ff, hp);
                            reflected = do_reflection(N, n_in, n_out, rng, pos, dir);
                        }
                    }

                    if (!reflected) {
                        mstate = new_ms;
                        mid = new_mid;

                        if (mid == 0u) {
                            mid = MEDIUM_DEAD;
                        }
                    }

                } else {
                    // MESH mode
                    uint new_mid = ff ? bm : fm;
                    bool reflected = false;

                    // Attempt reflection if crossing a refractive boundary
                    // Allow reflection at medium-to-ambient boundaries (tissue-to-air)
                    if (do_reflect > 0u && mid < num_media) {
                        float n_out = (new_mid < num_media) ? media[new_mid].n : 1.0;

                        if (prop.n != n_out) {
                            vec3 N = ff ? face_normal[tri * 2].xyz : -face_normal[tri * 2].xyz;
                            reflected = do_reflection(N, prop.n, n_out, rng, pos, dir);
                        }
                    }

                    if (!reflected) {
                        mid = new_mid;

                        if (mid == MEDIUM_AMBIENT) {
                            mid = MEDIUM_DEAD;
                        }
                    }
                }

            } else if (!hit && !is_transparent) {
                if (do_csg > 0u && ms_get(mstate, 0) == 0u) {
                    mid = MEDIUM_DEAD;
                } else {
                    float L = slen / prop.mus;
                    accumulate(pos, dir, mid, weight, tof, L);
                    pos += dir * L;
                    weight *= exp(-prop.mua * L);
                    tof += L * INV_C0 * prop.n;
                    dir = scatter_dir(dir, prop.g, rng);
                    slen = rand_scatlen(rng);
                }
            }
        }

        if (mid == MEDIUM_DEAD || mid == MEDIUM_AMBIENT || tof >= time_end) {
            launch_photon(pos, dir, weight, slen, tof, mid, mstate, rng);
            ++done;
        }
    }
}