/*
 * vkmmc_core.comp — Monte Carlo photon transport via Vulkan ray query
 *
 * Supports two modes:
 *   1. Mesh mode (do_csg=0): front/back media labels per triangle (tetrahedral mesh)
 *   2. CSG mode  (do_csg=1): shape-based, each triangle stores only back-material (Tag).
 *      A per-photon 8-byte state buffer tracks enclosing surfaces.
 *      Highest media ID among all enclosing surfaces determines the current medium.
 *
 * Curvature-informed reflection: when has_curvature=1, uses per-node principal
 * curvature to estimate the true surface normal at the intersection point,
 * yielding accurate Fresnel reflection/transmission on curved CSG surfaces.
 *
 * Compile: glslangValidator --target-env vulkan1.2 -e main -o vkmmc_core.spv vkmmc_core.comp
 */
#version 460
#extension GL_EXT_ray_query : require

// Uncomment for NVIDIA (Turing+)
//#define USE_ATOMIC_FLOAT

#ifdef USE_ATOMIC_FLOAT
    #extension GL_EXT_shader_atomic_float : require
#endif

layout(local_size_x = 64) in;

// ==================== Descriptor Bindings ====================

layout(set = 0, binding = 0) uniform accelerationStructureEXT scene;

layout(std430, set = 0, binding = 1) readonly buffer FaceBuffer {
    vec4 face_normal[];  // .xyz = normal, .w = packed media
};

struct Medium {
    float mua, mus, g, n;
};
layout(std430, set = 0, binding = 2) readonly buffer MediaBuffer { Medium media[]; };

#ifdef USE_ATOMIC_FLOAT
layout(std430, set = 0, binding = 3) buffer OutputBuffer { float output_data[]; };
#else
layout(std430, set = 0, binding = 3) buffer OutputBuffer { uint output_data[]; };
#endif

layout(std140, set = 0, binding = 4) uniform SimParams {
    vec4  src_pos, src_dir, src_param1, src_param2;
    vec4  grid_min, grid_extent;
    uvec4 grid_stride;
    float voxel_scale, time_start, time_end, inv_timestep;
    int   src_type, max_gate, output_type;
    uint  do_reflect;
    uint  initial_medium, total_threads, num_media, rng_seed;
    uint  do_csg, has_curvature;
    int   photons_per_thread, extra_photons;
};

layout(std430, set = 0, binding = 5) readonly buffer SeedBuffer { uvec4 thread_seeds[]; };

/* Per-node curvature: 3 x vec4 = 12 floats per node */
struct NodeCurv {
    vec4 vnorm_k1;   // .xyz = vertex normal, .w = k1
    vec4 pdir_k2;    // .xyz = principal direction 1, .w = k2
    vec4 node_pos;   // .xyz = node world position, .w = unused
};
layout(std430, set = 0, binding = 6) readonly buffer CurvBuffer { NodeCurv node_curv[]; };

// ==================== Constants ====================

const float INV_C0       = 3.335640951981520e-12;
const float SAFETY_DIST  = 0.001;
const float DOUBLE_SAFETY = 0.002;
const float TWO_PI       = 6.28318530717959;
const float FEPS         = 1.19209290E-07;
const float FMAX         = 3.402823466e+38;
const float RAY_TMIN     = 1e-5;

const uint MEDIUM_UNKNOWN = 0xFFFFFFFFu;
const uint MEDIUM_DEAD    = 0xFFFFFFFEu;
const uint MEDIUM_AMBIENT = 0u;
const int  OUT_FLUX = 0, OUT_FLUENCE = 1, OUT_ENERGY = 2;

// ==================== RNG (xorshift128+) ====================

float rand01(inout uvec4 st) {
    uvec2 s1 = st.xy, s0 = st.zw;
    st.xy = s0;
    s1 ^= uvec2(s1.x << 23u, (s1.y << 23u) | (s1.x >> 9u));
    uvec2 ns = s1 ^ s0 ^ uvec2((s1.x >> 18u) | (s1.y << 14u), s1.y >> 18u)
               ^ uvec2((s0.x >> 5u) | (s0.y << 27u), s0.y >> 5u);
    st.zw = ns;
    return uintBitsToFloat(0x3F800000u | ((ns.x + s0.x) >> 9u)) - 1.0;
}

float rand_range(inout uvec4 s, float a, float b) {
    return (b - a) * rand01(s) + a;
}
float rand_scatlen(inout uvec4 s) {
    return -log(rand01(s) + FEPS);
}

// ==================== Ray Tracing ====================

bool trace_ray(vec3 o, vec3 d, float tmin, float tmax,
               out float dist, out int tri_id, out bool front_face) {
    rayQueryEXT q;
    rayQueryInitializeEXT(q, scene, gl_RayFlagsNoneEXT, 0xFF, o, tmin, d, tmax);

    while (rayQueryProceedEXT(q)) {}

    if (rayQueryGetIntersectionTypeEXT(q, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
        dist = rayQueryGetIntersectionTEXT(q, true);
        tri_id = rayQueryGetIntersectionPrimitiveIndexEXT(q, true);
        front_face = rayQueryGetIntersectionFrontFaceEXT(q, true);
        return true;
    }

    return false;
}

/* Extended trace that also returns barycentric coordinates */
bool trace_ray_bary(vec3 o, vec3 d, float tmin, float tmax,
                    out float dist, out int tri_id, out bool front_face, out vec2 bary) {
    rayQueryEXT q;
    rayQueryInitializeEXT(q, scene, gl_RayFlagsNoneEXT, 0xFF, o, tmin, d, tmax);

    while (rayQueryProceedEXT(q)) {}

    if (rayQueryGetIntersectionTypeEXT(q, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
        dist = rayQueryGetIntersectionTEXT(q, true);
        tri_id = rayQueryGetIntersectionPrimitiveIndexEXT(q, true);
        front_face = rayQueryGetIntersectionFrontFaceEXT(q, true);
        bary = rayQueryGetIntersectionBarycentricsEXT(q, true);
        return true;
    }

    return false;
}

void unpack_media(float pw, out uint front_med, out uint back_med) {
    uint p = floatBitsToUint(pw);
    front_med = p >> 16u;
    back_med  = p & 0xFFFFu;
}

// ==================== Media State Buffer (CSG mode) ====================
// 8 slots of uint8, packed into uvec2

uint ms_get(uvec2 ms, int slot) {
    uint word = (slot < 4) ? ms.x : ms.y;
    return (word >> (uint(slot & 3) * 8u)) & 0xFFu;
}

uvec2 ms_set(uvec2 ms, int slot, uint val) {
    uint shift = uint(slot & 3) * 8u;
    uint mask = 0xFFu << shift;

    if (slot < 4) {
        ms.x = (ms.x & ~mask) | ((val & 0xFFu) << shift);
    } else {
        ms.y = (ms.y & ~mask) | ((val & 0xFFu) << shift);
    }

    return ms;
}

uint ms_max(uvec2 ms) {
    uint mx = 0u;

    for (int i = 0; i < 8; i++) {
        mx = max(mx, ms_get(ms, i));
    }

    return mx;
}

uvec2 ms_enter(uvec2 ms, uint back_id) {
    if (back_id == 0u) {
        return ms;
    }

    uint current_max = ms_get(ms, 0);
    uint new_max = max(current_max, back_id);
    uint demoted = (new_max == back_id) ? current_max : back_id;

    ms = ms_set(ms, 0, new_max);

    if (demoted > 0u) {
        for (int i = 1; i < 8; i++) {
            if (ms_get(ms, i) == 0u) {
                ms = ms_set(ms, i, demoted);
                break;
            }
        }
    }

    return ms;
}

uvec2 ms_leave(uvec2 ms, uint back_id) {
    if (back_id == 0u) {
        return ms;
    }

    for (int i = 0; i < 8; i++) {
        if (ms_get(ms, i) == back_id) {
            ms = ms_set(ms, i, 0u);
            break;
        }
    }

    uint mx = 0u;
    int mx_slot = -1;

    for (int i = 0; i < 8; i++) {
        uint v = ms_get(ms, i);

        if (v > mx) {
            mx = v;
            mx_slot = i;
        }
    }

    if (mx_slot > 0) {
        ms = ms_set(ms, mx_slot, 0u);
        ms = ms_set(ms, 0, mx);
    } else if (mx_slot < 0) {
        ms = ms_set(ms, 0, 0u);
    }

    return ms;
}

// ==================== Output Accumulation ====================

void atomic_add_float(uint idx, float val) {
#ifdef USE_ATOMIC_FLOAT
    atomicAdd(output_data[idx], val);
#else
    uint prev = output_data[idx], nv, old;

    do {
        old = prev;
        nv = floatBitsToUint(uintBitsToFloat(old) + val);
        prev = atomicCompSwap(output_data[idx], old, nv);
    } while (prev != old);

#endif
}

uint voxel_index(vec3 rp) {
    uint ix = rp.x > 0.0 ? uint(min(rp.x, grid_extent.x) * voxel_scale) : 0u;
    uint iy = rp.y > 0.0 ? uint(min(rp.y, grid_extent.y) * voxel_scale) : 0u;
    uint iz = rp.z > 0.0 ? uint(min(rp.z, grid_extent.z) * voxel_scale) : 0u;
    return iz * grid_stride.y + iy * grid_stride.x + ix;
}

uint time_offset(float tof) {
    return uint(min(int((tof - time_start) * inv_timestep), max_gate - 1)) * grid_stride.z;
}

void accumulate(vec3 p, vec3 d, uint mid, float w, float tof, float L) {
    Medium pr = media[mid];
    int sc = (int(L * voxel_scale) + 1) << 1;
    float sl = L / float(sc), decay = exp(-pr.mua * sl);
    float loss = (output_type == OUT_ENERGY) ? w * (1.0 - decay)
                 : (pr.mua > 0.0 ? w * (1.0 - decay) / pr.mua : 0.0);
    vec3 step = sl * d, sm = p - grid_min.xyz + 0.5 * step;
    float ct = tof + sl * INV_C0 * pr.n;
    uint oe = time_offset(ct) + voxel_index(sm);
    float ow = loss;

    for (int i = 1; i < sc; ++i) {
        loss *= decay;
        sm += step;
        ct += sl * INV_C0 * pr.n;
        uint ne = time_offset(ct) + voxel_index(sm);

        if (ne != oe) {
            atomic_add_float(oe, ow);
            oe = ne;
            ow = 0.0;
        }

        ow += loss;
    }

    atomic_add_float(oe, ow);
}

// ==================== Scattering ====================

vec3 rotate_dir(vec3 v, vec2 z, vec2 a) {
    if (v.z > -1.0 + FEPS && v.z < 1.0 - FEPS) {
        float s2 = 1.0 - v.z * v.z, sc = z.x * inversesqrt(s2);
        return sc * (a.y * vec3(v.x * v.z, v.y * v.z, -s2) + a.x * vec3(-v.y, v.x, 0.0)) + z.y * v;
    }

    return vec3(z.x * a.y, z.x * a.x, v.z > 0.0 ? z.y : -z.y);
}

vec3 scatter_dir(vec3 d, float g, inout uvec4 rng) {
    float ct;

    if (abs(g) > FEPS) {
        float t = (1.0 - g * g) / (1.0 - g + 2.0 * g * rand01(rng));
        ct = clamp((1.0 + g * g - t * t) / (2.0 * g), -1.0, 1.0);
    } else {
        ct = 2.0 * rand01(rng) - 1.0;
    }

    float phi = rand_range(rng, 0.0, TWO_PI);
    return rotate_dir(d, vec2(sin(acos(ct)), ct), vec2(sin(phi), cos(phi)));
}

// ==================== Fresnel Reflection ====================
// Returns true if reflected, false if transmitted.
// Updates pos and dir in-place.
// Now accepts an explicit normal vector N (may be curvature-corrected).

bool do_reflection(vec3 N, float n1, float n2, inout uvec4 rng, inout vec3 p, inout vec3 d) {
    // N should point toward the side the photon is coming from (outward for front-face hit)
    // Ensure ci = cos(incident angle) > 0 using the correct orientation
    float cid = dot(d, N);

    // If d and N point in the same direction (should not happen with correct N orientation),
    // flip N so that ci is positive
    if (cid > 0.0) {
        N = -N;
        cid = -cid;
    }

    float ci = -cid;  // ci > 0

    float n12 = n1 * n1, n22 = n2 * n2;
    float ct2 = 1.0 - n12 / n22 * (1.0 - ci * ci);

    if (ct2 > 0.0) {
        float ct = sqrt(ct2);
        // Fresnel reflectance (unpolarized)
        float re = n12 * ci * ci + n22 * ct2, im = 2.0 * n1 * n2 * ci * ct;
        float rp = (re - im) / (re + im);
        re = n22 * ci * ci + n12 * ct * ct;
        float rt = (rp + (re - im) / (re + im)) * 0.5;

        if (rand01(rng) <= rt) {
            // Reflection: d_r = d + 2*ci*N
            p -= d * DOUBLE_SAFETY;
            d = d + 2.0 * ci * N;
        } else {
            // Snell's law transmission: d_t = (n1/n2)*d + ((n1/n2)*ci - ct)*N
            float ratio = n1 / n2;
            d = ratio * d + (ratio * ci - ct) * N;
            d *= inversesqrt(dot(d, d));
            return false;
        }
    } else {
        // Total internal reflection
        p -= d * DOUBLE_SAFETY;
        d = d + 2.0 * ci * N;
    }

    d *= inversesqrt(dot(d, d));
    return true;
}

// ==================== Photon Launch ====================

void launch_photon(inout vec3 p, inout vec3 d, inout float w, inout float slen,
                   inout float tof, inout uint mid, inout uvec2 mstate, inout uvec4 rng) {
    p = src_pos.xyz;
    d = src_dir.xyz;
    w = 1.0;
    tof = 0.0;
    mstate = uvec2(0u, 0u);

    if (src_type == 4) { // planar
        float u = rand01(rng), v = rand01(rng);
        p = src_pos.xyz + u * src_param1.xyz + v * src_param2.xyz;
    } else if (src_type == 8) { // disk
        float r0 = sqrt(rand01(rng)) * src_param1.x;
        float phi = TWO_PI * rand01(rng);
        float cphi = cos(phi), sphi = sin(phi);
        // Build tangent plane perpendicular to src_dir
        vec3 sd = src_dir.xyz;

        if (sd.z > -1.0 + FEPS && sd.z < 1.0 - FEPS) {
            float tmp0 = 1.0 - sd.z * sd.z;
            float tmp1 = r0 * inversesqrt(tmp0);
            p.x += tmp1 * (sd.x * sd.z * cphi - sd.y * sphi);
            p.y += tmp1 * (sd.y * sd.z * cphi + sd.x * sphi);
            p.z -= tmp1 * tmp0 * cphi;
        } else {
            p.x += r0 * cphi;
            p.y += r0 * sphi;
        }
    }

    slen = rand_scatlen(rng);

    if (do_csg > 0u) {
        mstate = uvec2(0u, 0u);
        uint parity = 0u;
        vec3 walk_pos = p;

        for (int walk = 0; walk < 64; walk++) {
            float hd;
            int tid;
            bool ff;

            if (!trace_ray(walk_pos, d, RAY_TMIN, FMAX, hd, tid, ff)) {
                break;
            }

            uint fm, bm;
            unpack_media(face_normal[tid * 2].w, fm, bm);

            if (bm > 0u && bm <= 8u) {
                parity ^= (1u << (bm - 1u));
            }

            walk_pos = walk_pos + d * (hd + SAFETY_DIST);
        }

        for (int i = 0; i < 8; i++) {
            if ((parity & (1u << i)) != 0u) {
                mstate = ms_enter(mstate, uint(i + 1));
            }
        }

        mid = ms_get(mstate, 0);

        if (mid == 0u) {
            float hd;
            int tid;
            bool ff;

            if (trace_ray(p, d, 0.0, FMAX, hd, tid, ff) && ff) {
                uint fm, bm;
                unpack_media(face_normal[tid * 2].w, fm, bm);

                // Move to the surface
                p = p + d * (hd + SAFETY_DIST);
                mstate = ms_enter(mstate, bm);
                mid = ms_get(mstate, 0);

                // Apply Fresnel refraction at entry if refractive index mismatch
                if (do_reflect > 0u && mid < num_media) {
                    float n_in = 1.0;  // exterior
                    float n_out = media[mid].n;

                    if (n_in != n_out) {
                        // Get surface normal for refraction
                        vec3 N;

                        if (has_curvature > 0u) {
                            vec3 hit_pos = p - d * SAFETY_DIST;
                            vec4 vidx_raw = face_normal[tid * 2 + 1];
                            uint v0 = floatBitsToUint(vidx_raw.x);
                            uint v1 = floatBitsToUint(vidx_raw.y);
                            uint v2 = floatBitsToUint(vidx_raw.z);

                            vec3 N0 = node_curv[v0].vnorm_k1.xyz;
                            float k1_0 = node_curv[v0].vnorm_k1.w;
                            vec3 u0 = node_curv[v0].pdir_k2.xyz;
                            float k2_0 = node_curv[v0].pdir_k2.w;
                            vec3 P0 = node_curv[v0].node_pos.xyz;
                            vec3 dd0 = hit_pos - P0;
                            vec3 vv0 = cross(u0, N0);
                            vec3 NB0 = N0 - k1_0 * dot(dd0, u0) * u0 - k2_0 * dot(dd0, vv0) * vv0;

                            vec3 N1 = node_curv[v1].vnorm_k1.xyz;
                            float k1_1 = node_curv[v1].vnorm_k1.w;
                            vec3 u1 = node_curv[v1].pdir_k2.xyz;
                            float k2_1 = node_curv[v1].pdir_k2.w;
                            vec3 P1 = node_curv[v1].node_pos.xyz;
                            vec3 dd1 = hit_pos - P1;
                            vec3 vv1 = cross(u1, N1);
                            vec3 NB1 = N1 - k1_1 * dot(dd1, u1) * u1 - k2_1 * dot(dd1, vv1) * vv1;

                            vec3 N2 = node_curv[v2].vnorm_k1.xyz;
                            float k1_2 = node_curv[v2].vnorm_k1.w;
                            vec3 u2 = node_curv[v2].pdir_k2.xyz;
                            float k2_2 = node_curv[v2].pdir_k2.w;
                            vec3 P2 = node_curv[v2].node_pos.xyz;
                            vec3 dd2 = hit_pos - P2;
                            vec3 vv2 = cross(u2, N2);
                            vec3 NB2 = N2 - k1_2 * dot(dd2, u2) * u2 - k2_2 * dot(dd2, vv2) * vv2;

                            N = normalize((NB0 + NB1 + NB2) / 3.0);
                        } else {
                            N = -face_normal[tid * 2].xyz;  // front face, inward normal
                        }

                        if (dot(N, d) > 0.0) {
                            N = -N;
                        }

                        // Apply reflection/refraction
                        bool refl = do_reflection(N, n_in, n_out, rng, p, d);

                        if (refl) {
                            // Reflected back outside — photon doesn't enter
                            mstate = uvec2(0u, 0u);
                            mid = MEDIUM_DEAD;
                        }
                    }
                }
            } else {
                mid = MEDIUM_DEAD;
            }
        }
    } else {
        mid = initial_medium;

        if (mid == MEDIUM_UNKNOWN) {
            float hd;
            int tid;
            bool ff;

            if (trace_ray(p, d, 0.0, FMAX, hd, tid, ff)) {
                uint fm, bm;
                unpack_media(face_normal[tid * 2].w, fm, bm);
                mid = ff ? fm : bm;
            } else {
                mid = MEDIUM_DEAD;
            }
        }
    }
}

// ==================== Curvature-corrected normal at hit point ====================
// Uses per-node principal curvature to estimate the true surface normal.
// Averages curvature-corrected normals from 3 triangle vertices (Yen & Fang).
// Vertex indices are stored in face_normal[tri_id*2+1] (interleaved layout).
// Node positions are in node_curv[idx].node_pos.

vec3 get_curvature_normal(int tri_id, vec2 bary_uv, vec3 hit_pos) {
    vec4 vidx_raw = face_normal[tri_id * 2 + 1];
    vec3 NB_sum = vec3(0.0);

    for (int vi = 0; vi < 3; vi++) {
        uint idx = floatBitsToUint(vidx_raw[vi]);
        vec3 Ni  = node_curv[idx].vnorm_k1.xyz;
        float k1 = node_curv[idx].vnorm_k1.w;
        vec3 ui  = node_curv[idx].pdir_k2.xyz;
        float k2 = node_curv[idx].pdir_k2.w;
        vec3 Pi  = node_curv[idx].node_pos.xyz;
        vec3 vi2 = cross(ui, Ni);
        vec3 di  = hit_pos - Pi;
        float du = dot(di, ui);
        float dv = dot(di, vi2);
        NB_sum += Ni + k1 * du * ui + k2 * dv * vi2;
    }

    vec3 NB = normalize(NB_sum);

    // Ensure curvature normal is consistent with flat face normal direction
    vec3 flat_N = face_normal[tri_id * 2].xyz;

    if (dot(NB, flat_N) < 0.0) {
        NB = -NB;
    }

    return NB;
}

// ==================== Main ====================

void main() {
    uint tid = gl_GlobalInvocationID.x;

    if (tid >= total_threads) {
        return;
    }

    uvec4 rng = thread_seeds[tid];
    int done = 0, maxph = photons_per_thread + int(tid < uint(extra_photons));

    vec3 pos, dir;
    float weight, slen, tof;
    uint mid;
    uvec2 mstate;

    launch_photon(pos, dir, weight, slen, tof, mid, mstate, rng);

    while (done < maxph) {

        if (mid != MEDIUM_DEAD && mid != MEDIUM_AMBIENT) {
            Medium prop = media[mid];

            // Compute max travel distance: if mus > 0, use scattering length;
            // if mus ~ 0 (transparent medium), ray goes to next boundary
            bool is_transparent = (prop.mus < FEPS);
            float max_dist = is_transparent ? FMAX : slen / prop.mus;
            float hd;
            int tri;
            bool ff;
            vec2 bary_uv;

            bool hit;

            if (has_curvature > 0u) {
                hit = trace_ray_bary(pos, dir, RAY_TMIN, max_dist, hd, tri, ff, bary_uv);
            } else {
                hit = trace_ray(pos, dir, RAY_TMIN, max_dist, hd, tri, ff);
            }

            if (!hit && is_transparent) {
                // Transparent medium, no boundary: photon escapes
                mid = MEDIUM_DEAD;
            } else if (hit) {
                // ---- Boundary hit ----
                uint fm, bm;
                unpack_media(face_normal[tri * 2].w, fm, bm);
                float L = is_transparent ? hd : min(hd, slen / prop.mus);

                accumulate(pos, dir, mid, weight, tof, L);
                pos += dir * (L + SAFETY_DIST);
                weight *= exp(-prop.mua * L);
                tof += L * INV_C0 * prop.n;

                if (!is_transparent) {
                    slen -= L * prop.mus;
                }

                if (do_csg > 0u) {
                    // CSG mode: update state buffer and handle reflection
                    uint old_mid = mid;

                    uvec2 new_mstate;

                    if (ff) {
                        new_mstate = ms_enter(mstate, bm);
                    } else {
                        new_mstate = ms_leave(mstate, bm);
                    }

                    uint new_mid = ms_get(new_mstate, 0);

                    bool reflected = false;

                    if (do_reflect > 0u && new_mid != old_mid
                            && new_mid < num_media && old_mid < num_media) {
                        float n_in  = media[old_mid].n;
                        float n_out = (new_mid == 0u) ? 1.0 : media[new_mid].n;

                        if (n_in != n_out) {
                            vec3 N;

                            if (has_curvature > 0u) {
                                vec3 hit_pos = pos - dir * SAFETY_DIST;
                                N = get_curvature_normal(tri, bary_uv, hit_pos);
                            } else {
                                N = face_normal[tri * 2].xyz;
                            }

                            reflected = do_reflection(N, n_in, n_out, rng, pos, dir);
                        }
                    }

                    if (reflected) {
                        // Stay in current medium
                    } else {
                        mstate = new_mstate;
                        mid = new_mid;

                        if (mid == 0u) {
                            mid = MEDIUM_DEAD;
                        }
                    }

                } else {
                    // Mesh mode: direct front/back lookup
                    uint new_mid = ff ? bm : fm;

                    if (do_reflect > 0u && new_mid != MEDIUM_AMBIENT
                            && prop.n != media[new_mid].n) {
                        vec3 N = ff ? -face_normal[tri * 2].xyz : face_normal[tri * 2].xyz;

                        if (do_reflection(N, prop.n, media[new_mid].n, rng, pos, dir)) {
                            new_mid = ff ? fm : bm;
                        }
                    }

                    mid = new_mid;

                    if (mid == MEDIUM_AMBIENT) {
                        mid = MEDIUM_DEAD;
                    }
                }

            } else if (!hit && !is_transparent) {
                // ---- Miss: scattering event (only for scattering media) ----
                if (do_csg > 0u && ms_get(mstate, 0) == 0u) {
                    mid = MEDIUM_DEAD;
                } else {
                    float L = slen / prop.mus;
                    accumulate(pos, dir, mid, weight, tof, L);
                    pos += dir * L;
                    weight *= exp(-prop.mua * L);
                    tof += L * INV_C0 * prop.n;
                    dir = scatter_dir(dir, prop.g, rng);
                    slen = rand_scatlen(rng);
                }
            }
        }

        // ---- Termination & relaunch ----
        if (mid == MEDIUM_DEAD || mid == MEDIUM_AMBIENT || tof >= time_end) {
            launch_photon(pos, dir, weight, slen, tof, mid, mstate, rng);
            ++done;
        }
    }
}