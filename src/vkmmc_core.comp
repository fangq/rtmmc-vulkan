/*
 * vkmmc_core.comp — Monte Carlo photon transport via Vulkan ray query
 *
 * Supports two modes:
 *   1. Mesh mode (do_csg=0): front/back media labels per triangle (tetrahedral mesh)
 *   2. CSG mode  (do_csg=1): shape-based, each triangle stores only back-material (Tag).
 *      A per-photon 8-byte state buffer tracks enclosing surfaces.
 *      Highest media ID among all enclosing surfaces determines the current medium.
 *
 * For NVIDIA GPUs: uncomment the next line for native atomicAdd(float)
 * Compile: glslangValidator --target-env vulkan1.2 -e main -o vkmmc_core.spv vkmmc_core.comp
 */
#version 460
#extension GL_EXT_ray_query : require

// Uncomment for NVIDIA (Turing+)
//#define USE_ATOMIC_FLOAT

#ifdef USE_ATOMIC_FLOAT
    #extension GL_EXT_shader_atomic_float : require
#endif

layout(local_size_x = 64) in;

// ==================== Descriptor Bindings ====================

layout(set = 0, binding = 0) uniform accelerationStructureEXT scene;

layout(std430, set = 0, binding = 1) readonly buffer FaceBuffer {
    vec4 face_normal[];  // .xyz = normal, .w = packed media
};

struct Medium {
    float mua, mus, g, n;
};
layout(std430, set = 0, binding = 2) readonly buffer MediaBuffer { Medium media[]; };

#ifdef USE_ATOMIC_FLOAT
layout(std430, set = 0, binding = 3) buffer OutputBuffer { float output_data[]; };
#else
layout(std430, set = 0, binding = 3) buffer OutputBuffer { uint output_data[]; };
#endif

layout(std140, set = 0, binding = 4) uniform SimParams {
    int   src_type;
    int _p0, _p1, _p2;
    vec4  src_pos, src_dir, src_param1, src_param2;
    vec4  grid_min, grid_extent;
    uvec4 grid_stride;
    float voxel_scale, time_start, time_end, inv_timestep;
    int   max_gate;
    uint initial_medium, do_reflect;
    int   output_type, photons_per_thread, extra_photons;
    uint  total_threads, num_media, rng_seed;
    uint  do_csg;     // 0=mesh mode, 1=CSG mode
};

layout(std430, set = 0, binding = 5) readonly buffer SeedBuffer { uvec4 thread_seeds[]; };

// ==================== Constants ====================

const float INV_C0       = 3.335640951981520e-12;
const float SAFETY_DIST  = 0.001;
const float DOUBLE_SAFETY = 0.002;
const float TWO_PI       = 6.28318530717959;
const float FEPS         = 1.19209290E-07;
const float FMAX         = 3.402823466e+38;
const float RAY_TMIN     = 1e-5;

const uint MEDIUM_UNKNOWN = 0xFFFFFFFFu;
const uint MEDIUM_DEAD    = 0xFFFFFFFEu;
const uint MEDIUM_AMBIENT = 0u;
const int  OUT_FLUX = 0, OUT_FLUENCE = 1, OUT_ENERGY = 2;

// ==================== RNG (xorshift128+) ====================

float rand01(inout uvec4 st) {
    uvec2 s1 = st.xy, s0 = st.zw;
    st.xy = s0;
    s1 ^= uvec2(s1.x << 23u, (s1.y << 23u) | (s1.x >> 9u));
    uvec2 ns = s1 ^ s0 ^ uvec2((s1.x >> 18u) | (s1.y << 14u), s1.y >> 18u)
               ^ uvec2((s0.x >> 5u) | (s0.y << 27u), s0.y >> 5u);
    st.zw = ns;
    return uintBitsToFloat(0x3F800000u | ((ns.x + s0.x) >> 9u)) - 1.0;
}

float rand_range(inout uvec4 s, float a, float b) {
    return (b - a) * rand01(s) + a;
}
float rand_scatlen(inout uvec4 s) {
    return -log(rand01(s) + FEPS);
}

// ==================== Ray Tracing ====================

bool trace_ray(vec3 o, vec3 d, float tmin, float tmax,
               out float dist, out int tri_id, out bool front_face) {
    rayQueryEXT q;
    rayQueryInitializeEXT(q, scene, gl_RayFlagsNoneEXT, 0xFF, o, tmin, d, tmax);

    while (rayQueryProceedEXT(q)) {}

    if (rayQueryGetIntersectionTypeEXT(q, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
        dist = rayQueryGetIntersectionTEXT(q, true);
        tri_id = rayQueryGetIntersectionPrimitiveIndexEXT(q, true);
        front_face = rayQueryGetIntersectionFrontFaceEXT(q, true);
        return true;
    }

    return false;
}

void unpack_media(float pw, out uint front_med, out uint back_med) {
    uint p = floatBitsToUint(pw);
    front_med = p >> 16u;
    back_med  = p & 0xFFFFu;
}

// ==================== Media State Buffer (CSG mode) ====================
// 8 slots of uint8, packed into uvec2 (mediastate.x = slots 0-3, .y = slots 4-7)
// Slot 0 always holds the highest (active) media ID.

uint ms_get(uvec2 ms, int slot) {
    uint word = (slot < 4) ? ms.x : ms.y;
    return (word >> (uint(slot & 3) * 8u)) & 0xFFu;
}

uvec2 ms_set(uvec2 ms, int slot, uint val) {
    uint shift = uint(slot & 3) * 8u;
    uint mask = 0xFFu << shift;

    if (slot < 4) {
        ms.x = (ms.x & ~mask) | ((val & 0xFFu) << shift);
    } else {
        ms.y = (ms.y & ~mask) | ((val & 0xFFu) << shift);
    }

    return ms;
}

// Find the highest media ID across all 8 slots
uint ms_max(uvec2 ms) {
    uint mx = 0u;

    for (int i = 0; i < 8; i++) {
        mx = max(mx, ms_get(ms, i));
    }

    return mx;
}

// Enter a surface: write back_id into the state buffer
// The highest ID goes to slot 0; old slot 0 value moves to first empty slot
uvec2 ms_enter(uvec2 ms, uint back_id) {
    if (back_id == 0u) {
        return ms;
    }

    uint current_max = ms_get(ms, 0);
    uint new_max = max(current_max, back_id);
    uint demoted = (new_max == back_id) ? current_max : back_id;

    // Write the highest to slot 0
    ms = ms_set(ms, 0, new_max);

    // Write the demoted value to the first empty slot (if nonzero)
    if (demoted > 0u) {
        for (int i = 1; i < 8; i++) {
            if (ms_get(ms, i) == 0u) {
                ms = ms_set(ms, i, demoted);
                break;
            }
        }
    }

    return ms;
}

// Leave a surface: find back_id in the buffer and zero it, then update slot 0
uvec2 ms_leave(uvec2 ms, uint back_id) {
    if (back_id == 0u) {
        return ms;
    }

    // Find and remove back_id (search all slots including 0)
    for (int i = 0; i < 8; i++) {
        if (ms_get(ms, i) == back_id) {
            ms = ms_set(ms, i, 0u);
            break;
        }
    }

    // Recalculate max and put it in slot 0
    uint mx = 0u;
    int mx_slot = -1;

    for (int i = 0; i < 8; i++) {
        uint v = ms_get(ms, i);

        if (v > mx) {
            mx = v;
            mx_slot = i;
        }
    }

    if (mx_slot > 0) {
        ms = ms_set(ms, mx_slot, 0u);
        ms = ms_set(ms, 0, mx);
    } else if (mx_slot < 0) {
        ms = ms_set(ms, 0, 0u);
    }

    return ms;
}

// ==================== Output Accumulation ====================

void atomic_add_float(uint idx, float val) {
#ifdef USE_ATOMIC_FLOAT
    atomicAdd(output_data[idx], val);
#else
    uint prev = output_data[idx], nv, old;

    do {
        old = prev;
        nv = floatBitsToUint(uintBitsToFloat(old) + val);
        prev = atomicCompSwap(output_data[idx], old, nv);
    } while (prev != old);

#endif
}

uint voxel_index(vec3 rp) {
    uint ix = rp.x > 0.0 ? uint(min(rp.x, grid_extent.x) * voxel_scale) : 0u;
    uint iy = rp.y > 0.0 ? uint(min(rp.y, grid_extent.y) * voxel_scale) : 0u;
    uint iz = rp.z > 0.0 ? uint(min(rp.z, grid_extent.z) * voxel_scale) : 0u;
    return iz * grid_stride.y + iy * grid_stride.x + ix;
}

uint time_offset(float tof) {
    return uint(min(int((tof - time_start) * inv_timestep), max_gate - 1)) * grid_stride.z;
}

void accumulate(vec3 p, vec3 d, uint mid, float w, float tof, float L) {
    Medium pr = media[mid];
    int sc = (int(L * voxel_scale) + 1) << 1;
    float sl = L / float(sc), decay = exp(-pr.mua * sl);
    float loss = (output_type == OUT_ENERGY) ? w * (1.0 - decay)
                 : (pr.mua > 0.0 ? w * (1.0 - decay) / pr.mua : 0.0);
    vec3 step = sl * d, sm = p - grid_min.xyz + 0.5 * step;
    float ct = tof + sl * INV_C0 * pr.n;
    uint oe = time_offset(ct) + voxel_index(sm);
    float ow = loss;

    for (int i = 1; i < sc; ++i) {
        loss *= decay;
        sm += step;
        ct += sl * INV_C0 * pr.n;
        uint ne = time_offset(ct) + voxel_index(sm);

        if (ne != oe) {
            atomic_add_float(oe, ow);
            oe = ne;
            ow = 0.0;
        }

        ow += loss;
    }

    atomic_add_float(oe, ow);
}

// ==================== Scattering ====================

vec3 rotate_dir(vec3 v, vec2 z, vec2 a) {
    if (v.z > -1.0 + FEPS && v.z < 1.0 - FEPS) {
        float s2 = 1.0 - v.z * v.z, sc = z.x * inversesqrt(s2);
        return sc * (a.y * vec3(v.x * v.z, v.y * v.z, -s2) + a.x * vec3(-v.y, v.x, 0.0)) + z.y * v;
    }

    return vec3(z.x * a.y, z.x * a.x, v.z > 0.0 ? z.y : -z.y);
}

vec3 scatter_dir(vec3 d, float g, inout uvec4 rng) {
    float ct;

    if (abs(g) > FEPS) {
        float t = (1.0 - g * g) / (1.0 - g + 2.0 * g * rand01(rng));
        ct = clamp((1.0 + g * g - t * t) / (2.0 * g), -1.0, 1.0);
    } else {
        ct = 2.0 * rand01(rng) - 1.0;
    }

    float phi = rand_range(rng, 0.0, TWO_PI);
    return rotate_dir(d, vec2(sin(acos(ct)), ct), vec2(sin(phi), cos(phi)));
}

// ==================== Fresnel Reflection ====================

bool do_reflection(vec3 N, float n1, float n2, inout uvec4 rng, inout vec3 p, inout vec3 d) {
    float ci = abs(dot(d, N));
    float n12 = n1 * n1, n22 = n2 * n2, ct2 = 1.0 - n12 / n22 * (1.0 - ci * ci);

    if (ct2 > 0.0) {
        float ct = sqrt(ct2);
        float re = n12 * ci * ci + n22 * ct2, im = 2.0 * n1 * n2 * ci * ct;
        float rp = (re - im) / (re + im);
        re = n22 * ci * ci + n12 * ct * ct;
        float rt = (rp + (re - im) / (re + im)) * 0.5;

        if (rand01(rng) <= rt) {
            p -= d * DOUBLE_SAFETY;
            d += -2.0 * ci * N;
        } else {
            d += -ci * N;
            d = ct * N + n1 / n2 * d;
            d *= inversesqrt(dot(d, d));
            return false;
        }
    } else {
        p -= d * DOUBLE_SAFETY;
        d += -2.0 * ci * N;
    }

    d *= inversesqrt(dot(d, d));
    return true;
}

// ==================== Photon Launch ====================

void launch_photon(inout vec3 p, inout vec3 d, inout float w, inout float slen,
                   inout float tof, inout uint mid, inout uvec2 mstate, inout uvec4 rng) {
    p = src_pos.xyz;
    d = src_dir.xyz;
    w = 1.0;
    tof = 0.0;
    mstate = uvec2(0u, 0u); // clear state buffer

    if (src_type == 4) { // planar
        float u = rand01(rng), v = rand01(rng);
        p = src_pos.xyz + u * src_param1.xyz + v * src_param2.xyz;
    }

    slen = rand_scatlen(rng);

    if (do_csg > 0u) {
        // CSG mode: determine enclosing surfaces using parity counting.
        // Cast ray forward, walk through ALL intersections. For each surface (back_id),
        // count crossings. Odd count = source is inside that surface.
        // We use a temporary counter packed into mstate, then convert to enter calls.
        mstate = uvec2(0u, 0u);

        // Count crossings per back_id (use state buffer slots as counters mod 2)
        // Since we have up to 8 media IDs, track parity for each
        uint parity[8]; // parity[i] = crossing count for media id (i+1), mod 2

        for (int i = 0; i < 8; i++) {
            parity[i] = 0u;
        }

        vec3 walk_pos = p;

        for (int walk = 0; walk < 64; walk++) {
            float hd;
            int tid;
            bool ff;

            if (!trace_ray(walk_pos, d, RAY_TMIN, FMAX, hd, tid, ff)) {
                break;
            }

            uint fm, bm;
            unpack_media(face_normal[tid].w, fm, bm);

            // Every crossing of a surface with back_id=bm toggles parity
            if (bm > 0u && bm <= 8u) {
                parity[bm - 1u] ^= 1u;
            }

            walk_pos = walk_pos + d * (hd + SAFETY_DIST);
        }

        // Odd parity = source is inside that surface → enter it
        for (int i = 0; i < 8; i++) {
            if (parity[i] != 0u) {
                mstate = ms_enter(mstate, uint(i + 1));
            }
        }

        mid = ms_get(mstate, 0);

        if (mid == 0u) {
            // Source is outside all surfaces — skip forward to first entry
            float hd;
            int tid;
            bool ff;

            if (trace_ray(p, d, 0.0, FMAX, hd, tid, ff) && ff) {
                uint fm, bm;
                unpack_media(face_normal[tid].w, fm, bm);
                p = p + d * (hd + SAFETY_DIST);
                mstate = ms_enter(mstate, bm);
                mid = ms_get(mstate, 0);
            } else {
                mid = MEDIUM_DEAD;
            }
        }
    } else {
        // Mesh mode: use precomputed initial_medium or ray query
        mid = initial_medium;

        if (mid == MEDIUM_UNKNOWN) {
            float hd;
            int tid;
            bool ff;

            if (trace_ray(p, d, 0.0, FMAX, hd, tid, ff)) {
                uint fm, bm;
                unpack_media(face_normal[tid].w, fm, bm);
                mid = ff ? fm : bm;
            } else {
                mid = MEDIUM_DEAD;
            }
        }
    }
}

// ==================== Main ====================

void main() {
    uint tid = gl_GlobalInvocationID.x;

    if (tid >= total_threads) {
        return;
    }

    uvec4 rng = thread_seeds[tid];
    int done = 0, maxph = photons_per_thread + int(tid < uint(extra_photons));

    vec3 pos, dir;
    float weight, slen, tof;
    uint mid;
    uvec2 mstate; // CSG media state buffer (8 x uint8)

    launch_photon(pos, dir, weight, slen, tof, mid, mstate, rng);

    while (done < maxph) {

        if (mid != MEDIUM_DEAD && mid != MEDIUM_AMBIENT) {
            Medium prop = media[mid];

            if (prop.mus < FEPS) {
                mid = MEDIUM_DEAD;
            } else {
                float max_dist = slen / prop.mus;
                float hd;
                int tri;
                bool ff;
                bool hit = trace_ray(pos, dir, RAY_TMIN, max_dist, hd, tri, ff);

                if (hit) {
                    // ---- Boundary hit ----
                    uint fm, bm;
                    unpack_media(face_normal[tri].w, fm, bm);
                    float L = min(hd, slen / prop.mus);

                    accumulate(pos, dir, mid, weight, tof, L);
                    pos += dir * (L + SAFETY_DIST);
                    weight *= exp(-prop.mua * L);
                    tof += L * INV_C0 * prop.n;
                    slen -= L * prop.mus;

                    if (do_csg > 0u) {
                        // CSG mode: update state buffer and handle reflection

                        // Determine the old medium (before crossing) and new medium (after crossing)
                        uint old_mid = mid;  // current medium before state update

                        // Tentatively update state to find what new medium would be
                        uvec2 new_mstate;

                        if (ff) {
                            // Front-face hit: entering this surface → add back_id
                            new_mstate = ms_enter(mstate, bm);
                        } else {
                            // Back-face hit: leaving this surface → remove back_id
                            new_mstate = ms_leave(mstate, bm);
                        }

                        uint new_mid = ms_get(new_mstate, 0);

                        // Check for reflection at refractive index boundary
                        bool reflected = false;

                        if (do_reflect > 0u && new_mid != old_mid
                                && new_mid < num_media && old_mid < num_media) {
                            float n_in  = media[old_mid].n;
                            float n_out = (new_mid == 0u) ? 1.0 : media[new_mid].n;

                            if (n_in != n_out) {
                                // Get face normal, oriented toward the incoming ray
                                vec3 N = ff ? -face_normal[tri].xyz : face_normal[tri].xyz;

                                // do_reflection returns true if reflected, false if transmitted
                                // it also updates pos and dir accordingly
                                reflected = do_reflection(N, n_in, n_out, rng, pos, dir);
                            }
                        }

                        if (reflected) {
                            // Photon bounced back — do NOT update state buffer
                            // mid stays the same (old_mid)
                            // pos and dir were already updated by do_reflection
                        } else {
                            // Transmitted (or no index mismatch) — commit the state update
                            mstate = new_mstate;
                            mid = new_mid;

                            if (mid == 0u) {
                                mid = MEDIUM_DEAD;  // exited all surfaces
                            }
                        }

                    } else {
                        // Mesh mode: direct front/back lookup
                        uint new_mid = ff ? bm : fm;

                        if (do_reflect > 0u && new_mid != MEDIUM_AMBIENT
                                && prop.n != media[new_mid].n) {
                            vec3 N = ff ? -face_normal[tri].xyz : face_normal[tri].xyz;

                            if (do_reflection(N, prop.n, media[new_mid].n, rng, pos, dir)) {
                                new_mid = ff ? fm : bm; // reflected
                            }
                        }

                        mid = new_mid;

                        if (mid == MEDIUM_AMBIENT) {
                            mid = MEDIUM_DEAD;
                        }
                    }

                } else {
                    // ---- Miss: scattering event ----
                    if (do_csg > 0u && ms_get(mstate, 0) == 0u) {
                        // CSG mode: miss while outside all surfaces → terminate
                        mid = MEDIUM_DEAD;
                    } else {
                        float L = slen / prop.mus;
                        accumulate(pos, dir, mid, weight, tof, L);
                        pos += dir * L;
                        weight *= exp(-prop.mua * L);
                        tof += L * INV_C0 * prop.n;
                        dir = scatter_dir(dir, prop.g, rng);
                        slen = rand_scatlen(rng);
                    }
                }
            }
        }

        // ---- Termination & relaunch ----
        if (mid == MEDIUM_DEAD || mid == MEDIUM_AMBIENT || tof >= time_end) {
            launch_photon(pos, dir, weight, slen, tof, mid, mstate, rng);
            ++done;
        }
    }
}